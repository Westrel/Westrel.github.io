<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
    <meta name="description" content="Designed by Wx">
  

  
    <meta name="keywords" content="由列表掉落关键词">
  

  
    <meta name="author" content="Westrel Xylographer">
  

  

  

  <title>上帝的暴击不随机 | 你是光</title>

  

  
    <link rel="icon" href="/favicon.ico">
  

  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.6/styles/monokai.min.css" rel="stylesheet">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div class="root-container">
    <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          你是光
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/categories">目录</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/tags">标签</a></li>
        
          <li class="navbar-list-item"><a href="/messages">留盐</a></li>
        
      </ul>
    </div>
  </div>
</nav>

    
<!-- header container -->
<header class="header-container post">

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-image" style="background-image: url(../images/randomgod/touzi.jpg)"></div>
      <div class="post-text">
        <div class="type-wrap">
          <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
        </div>
        <h1 class="title-wrap">上帝的暴击不随机</h1>
        <h2 class="title-sub-wrap">
          <strong>Westrel Xylographer</strong>
          <span>发布于</span>
          
  <a href="javascript:;" class="article-date">
    <time datetime="2020-02-23T09:26:28.000Z" itemprop="datePublished">2020-02-23</time>
  </a>

        </h2>
      </div>
    </div>
  

  
  

  </header>

    <!-- 文章 -->

<!-- 文章内容 -->

<div class="body-container">
  <article class="content-container article-container">
    <div class="article-content">
      
      

      <div class="article-entry">
        <p>在Moba游戏当中，我最喜欢的职业（之一）就是ADC。ADC讲究啥，你得高频率、高力度（污）对敌方输出伤害。一个好的ADC会说：“队友叫我先打输出后打肉，在我面前都是两三次平A的事~”</p>
<p>看起来这很考验ADC玩家的手速。当你的攻速已经叠满攻击已经最高的时候，在不考虑对方护甲和你的减甲的情况下理论上你的秒输出量是固定的攻速x攻击力。这样可不行，普攻脆皮还说得过去，对面一个4000血的胖胖朝着你飞奔过来的时候，你怎样才能踩着这个圆滚滚的尸体对着你的奶妈和中单吹嘘上面那句话呢？</p>
<p>暴击。</p>
<p>对嘛，只要你一次攻击打出了更高的伤害，不就可以更快地解决掉对面的前排了嘛！</p>
<p>于是，各大Moba或者RPG游戏便引入了暴击机制。暴击机制的通常理解是这样的：你所进行的每一次可暴击的操作（比如普攻）有一个固定的暴击率P，假设未暴击的情况下你的操作为d，如果触发了暴击，那么你造成的伤害便为你的普攻乘上预设的暴击倍率r，即d*r。</p>
<p>这很好理解。比如你的普通攻击的面板伤害为100点，你当前的暴击率是20%，大多数游戏所设置的初始暴击倍率都是2倍，这时你的普通攻击就有20%的几率打出200点的面板伤害。如果用统计学的方法计算的话，你的每次攻击造成的面板伤害均值为（0.8x100+0.2x200=）120点。</p>
<p>那么这个时候，当你出了一件暴击装备的之后，你在对敌方单位的每一次攻击都期望出暴击，这样你就可以更容易地击杀对方获取赏金赢得游戏当上CEO迎娶白富美走上人生巅峰…咳咳跑题了，总之，多出暴击就是你所期盼的事情。</p>
<p>但是常常事情并不如你所愿，可能你20%的暴击率连续点了对方ADC30下一个暴击也没出，可能对面ADC5%的暴击率点你3下出了两个暴击…（你好非哦~）</p>
<p>于是你砸鼠标扔键盘，咒骂着游戏公司然后退游。游戏公司当然不希望你做出这种事。于是，为了盈利（其实并不），他们的算法工程师开发出了<b>PRD（Pseudo Random Distribution)机制</b>，专门针对这种经常连续暴击或者连续不暴击的情况。</p>
<h3 id="PRD机制"><a href="#PRD机制" class="headerlink" title="PRD机制"></a>PRD机制</h3><p>PRD机制出暴击的流程是这样的，首先，有一个你能看见的你的暴击率，比如20%，我们称之为面板暴击率P，而你每次普通攻击的当前暴击率的值为p(n)=c*n，n为距离上一次暴击有几次未暴击，n从1开始计数，而对于每一个固定的面板暴击率P都有一个对应的c值，这个c值通常都是比其P要低的。这样，如果你上一次普攻出了暴击，那么你下一次出暴击的概率就很低；同样的，如果你连续很多次都没有出暴击，那么你下次普攻的暴击率会逐渐上升甚至可能达到100%，这样就避免了连续若干个普攻都出不了暴击的非酋情况。</p>
<p><img src="https://github.com/Westrel/Westrel.github.io/tree/master/images/randomgod/Cvalue.jpg" alt="C value" title="C值表"></p>
<p>从表中可以看出，假设你的面板暴击率为20%，对应的C值约为5%，也就是说，你的第一次普攻的暴击率只有5%左右，第二次暴击率就叠加到10%，如果你连续十七八次都没有出暴击，那么下一次的暴击率会接近甚至达到100%，而一旦你出了暴击，下一次你的真实暴击率就又回到了5%。</p>
<h3 id="python实现-不想看代码的直接略过看结果"><a href="#python实现-不想看代码的直接略过看结果" class="headerlink" title="python实现(不想看代码的直接略过看结果)"></a>python实现(不想看代码的直接略过看结果)</h3><p>有了算法的理论基础，我们来考虑实现它。</p>
<p>首先我们定义了一个CRIT类，是基础暴击类，等会我们要写一个PRD类和NOMALCRIT普通暴击类都是继承自它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CRIT</span><span class="hljs-params">(object)</span>:</span><br>    crit_rate = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, rate=<span class="hljs-number">0</span>)</span>:</span><br>        self.setCritRate(rate)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setCritRate</span><span class="hljs-params">(self, rate)</span>:</span><br>        self.crit_rate = rate<br>        <span class="hljs-keyword">return</span> rate<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isAttackCrit</span><span class="hljs-params">(self, rate)</span>:</span><br>        rad = random.random()<br>        <span class="hljs-keyword">if</span> rad&lt;=rate:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>

<p>CRIT类没啥好说的，有一个类变量crit_rate代表暴击率，在实例初始化的时候会被setCritRate方法初始化为你传入的rate的值，而isAttackCrit方法则用伪随机（即计算机产生随机数）的方法判断你的当次攻击有没有暴击。</p>
<p>接下来我们实现会产生欧皇非酋情况的NOMALCRIT类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># P(n)=p</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NOMALCRIT</span><span class="hljs-params">(CRIT)</span>:</span><br>    crit_rate = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, rate=<span class="hljs-number">0</span>)</span>:</span><br>        super().__init__(rate)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setCritRate</span><span class="hljs-params">(self, rate)</span>:</span><br>        self.crit_rate = rate<br>        <span class="hljs-keyword">return</span> rate<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isAttackCrit</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> super().isAttackCrit(self.crit_rate)<br></code></pre></td></tr></table></figure>

<p>这个类对于父类几乎没有改动，最大的区别就在于isAttackCrit方法是将自身crit_rate传回父类进行判断，然后将结果饭后给调用的地方。</p>
<p>PRD类内容有点多，我们先把代码贴出来，然后一部分一部分地说。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># P(n)=n*C</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PRD</span><span class="hljs-params">(CRIT)</span>:</span><br>    intRateBasicC = &#123;&#125;<br>    panel_crit_rate = <span class="hljs-number">0</span><br>    basic_crit_rate = <span class="hljs-number">0</span><br>    last = <span class="hljs-number">1</span><br>    current_rate = last*basic_crit_rate<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, rate=<span class="hljs-number">0</span>)</span>:</span><br>        super().__init__(rate)<br>        self.calC()<br>        self.setCritRate(rate)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">curP</span><span class="hljs-params">(self, b_r)</span>:</span><br>        <span class="hljs-keyword">if</span> b_r&gt;=<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> b_r&lt;=<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        n_max = <span class="hljs-number">1</span>/b_r<br>        <span class="hljs-keyword">if</span> type(n_max) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> int:<br>            n_max = int(n_max) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">assert</span>(type(n_max) <span class="hljs-keyword">is</span> int)<br>        fore_success_p = <span class="hljs-number">0</span><br>        exp_p = <span class="hljs-number">0</span><br>        cur_p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n_max):<br>            cur_p = min(<span class="hljs-number">1</span>, i * b_r) * (<span class="hljs-number">1</span>-fore_success_p)<br>            fore_success_p += cur_p<br>            exp_p += i * cur_p<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/exp_p<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">curC</span><span class="hljs-params">(self, p_r)</span>:</span><br>        max_r = p_r<br>        min_r = <span class="hljs-number">0</span><br>        mid_r = (max_r + min_r)/<span class="hljs-number">2.</span><br>        p_last = <span class="hljs-number">1.</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            p_now = self.curP(mid_r)<br>            <span class="hljs-keyword">if</span> abs(p_now-p_last)&lt;=<span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> mid_r<br>            <span class="hljs-keyword">if</span> p_now&gt;p_r:<br>                max_r = mid_r<br>            <span class="hljs-keyword">else</span>:<br>                min_r = mid_r<br>            mid_r = (max_r + min_r)/<span class="hljs-number">2.</span><br>            p_last = p_now<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calC</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>):<br>            self.intRateBasicC[i/<span class="hljs-number">100</span>] = self.curC(i/<span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setCritRate</span><span class="hljs-params">(self, rate)</span>:</span><br>        self.panel_crit_rate = rate<br>        <span class="hljs-keyword">if</span> self.panel_crit_rate <span class="hljs-keyword">in</span> self.intRateBasicC:<br>            self.basic_crit_rate = self.intRateBasicC[self.panel_crit_rate]<br>        <span class="hljs-keyword">else</span>:<br>            self.basic_crit_rate = self.curC(rate)<br>        self.current_rate = self.last*self.basic_crit_rate<br>        <span class="hljs-keyword">return</span> self.panel_crit_rate, self.basic_crit_rate<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isAttackCrit</span><span class="hljs-params">(self)</span>:</span><br>        res = super().isAttackCrit(self.current_rate)<br>        <span class="hljs-keyword">if</span> res:<br>            self.last = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            self.last += <span class="hljs-number">1</span><br>        self.current_rate = self.basic_crit_rate*self.last<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<p>先来看看类成员变量，intRateBasicC是一个字典，用于保存C值。这个字典我们会在每次创建实例的时候更新，将以1%为步长从0到100%的面板暴击率P对应的C值保存进去（P:C）。panel_crit_rate是当前面板暴击率，basic_crit_rate是当前c值。last是从上一次暴击开始数，到前一次攻击的总次数，是从1开始计数的。current_rate是当前实际暴击率也就是last*basic_crit_rate</p>
<p>我们通过curP方法和curC方法计算每一个P对应的C。并在calC方法中更新字典中的P:C键值对。</p>
<p>curC方法进行传入面板暴击率返回基础暴击率c的操作，curP辅助curC计算，传入基础暴击率计算基础暴击率对应的暴击期望值，我们需要用这个值来拟合真实值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">curC</span><span class="hljs-params">(self, p_r)</span>:</span><br>    max_r = p_r<br>    min_r = <span class="hljs-number">0</span><br>    mid_r = (max_r + min_r)/<span class="hljs-number">2.</span><br>    p_last = <span class="hljs-number">1.</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        p_now = self.curP(mid_r)<br>        <span class="hljs-keyword">if</span> abs(p_now-p_last)&lt;=<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> mid_r<br>        <span class="hljs-keyword">if</span> p_now&gt;p_r:<br>            max_r = mid_r<br>        <span class="hljs-keyword">else</span>:<br>            min_r = mid_r<br>        mid_r = (max_r + min_r)/<span class="hljs-number">2.</span><br>        p_last = p_now<br></code></pre></td></tr></table></figure>

<p>在curC方法中，我们使用二分法不断逼近真实值，由于计算机会存在<a href="https://www.cnblogs.com/w-guangyu/p/10597680.html" target="_blank" rel="noopener">浮点误差</a>，我们不采用当前基础暴击率与所要的面板值作比较，而是将当前基础暴击率的期望与上一次计算的期望比较，当这个期望值不变了，我们就视作其已经逼近了我们需要的真实的c值（第8行）。</p>
<p>对于每一个基础暴击率，我们用curP方法返回它的期望暴击率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">curP</span><span class="hljs-params">(self, b_r)</span>:</span><br>    <span class="hljs-keyword">if</span> b_r&gt;=<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> b_r&lt;=<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    n_max = <span class="hljs-number">1</span>/b_r<br>    <span class="hljs-keyword">if</span> type(n_max) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> int:<br>        n_max = int(n_max) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">assert</span>(type(n_max) <span class="hljs-keyword">is</span> int)<br>    fore_success_p = <span class="hljs-number">0</span><br>    exp_p = <span class="hljs-number">0</span><br>    cur_p = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n_max):<br>        cur_p = min(<span class="hljs-number">1</span>, i * b_r) * (<span class="hljs-number">1</span>-fore_success_p)<br>        fore_success_p += cur_p<br>        exp_p += i * cur_p<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/exp_p<br></code></pre></td></tr></table></figure>

<p>在这个函数中，我们通过计算当前数学期望的方法返回概率。首先，我们确定在这个基础暴击率下的最大攻击次数n_max，然后用cur_p迭代每一次未暴击普攻的暴击率，fore_success_p保存之前的暴击率和，exp_p保存暴击率的数学期望，最后用1/期望返回概率。</p>
<p>计算c值这个大头搞完之后其他都是很简单的啦，比如设置暴击率就是将当前面板暴击率赋值给对应成员变量，然后看看intRateBasicC有没有对应的c值，有就读取没有就用curC重新计算，并将结果赋值给对应的basic_crict_rate，最后当前实际暴击率为last与bc的乘积。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setCritRate</span><span class="hljs-params">(self, rate)</span>:</span><br>    self.panel_crit_rate = rate<br>    <span class="hljs-keyword">if</span> self.panel_crit_rate <span class="hljs-keyword">in</span> self.intRateBasicC:<br>        self.basic_crit_rate = self.intRateBasicC[self.panel_crit_rate]<br>    <span class="hljs-keyword">else</span>:<br>        self.basic_crit_rate = self.curC(rate)<br>    self.current_rate = self.last*self.basic_crit_rate<br>    <span class="hljs-keyword">return</span> self.panel_crit_rate, self.basic_crit_rate<br></code></pre></td></tr></table></figure>

<p>isAttackCrit方法与常规算法不同的地方就在于传给父类的暴击率为实际暴击率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isAttackCrit</span><span class="hljs-params">(self)</span>:</span><br>    res = super().isAttackCrit(self.current_rate)<br>    <span class="hljs-keyword">if</span> res:<br>        self.last = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        self.last += <span class="hljs-number">1</span><br>    self.current_rate = self.basic_crit_rate*self.last<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<p>嘿嘿，核心代码都写完了，就开始测试了。</p>
<h3 id="对比纯伪随机算法与PRD算法打出的暴击有什么异同吧"><a href="#对比纯伪随机算法与PRD算法打出的暴击有什么异同吧" class="headerlink" title="对比纯伪随机算法与PRD算法打出的暴击有什么异同吧"></a>对比纯伪随机算法与PRD算法打出的暴击有什么异同吧</h3><p>我们用PRD类和NOMALCRIT类分别创建了一个实例，基础攻击都为1点，都赋予20%的暴击率和2倍的基础暴击率。现在让他们同时攻击10000次，看看他们能打出怎样的伤害吧~</p>
<hr>
<p>输出:</p>
<p>PRD mode cause 12014.0 damage.</p>
<p>Nomal mode cause: 11955.0 damage.</p>
<hr>
<p>都打出了12000左右的伤害，和我们的计算结果(0.8x1+0.2x2=)1.2x10000的预期结果相差不大。</p>
<p>但是我们的关注点肯定不是在总伤害上面。我们想看的是它每次暴击都出现在第几次攻击上，这样才能看出来这个人是非酋还是欧皇。</p>
<p>emm…满足你，这里分别显示了两种暴击计算方式下分别在第几次攻击出现暴击，emm…由于2000条记录实在太长，我这里只选了前50次。</p>
<hr>
<p>输出:</p>
<p>PRD mode crit position: [6, 9, 12, 18, 26, 27, 28, 37, 41, 49, 56, 62, 65, 71, 72, 80, 81, 88, 95, 101, 109, 117, 122, 128, 134, 141, 147, 150, 154, 159, 165, 171, 174, 179, 186, 189, 194, 204, 211, 215, 218, 219, 221, 223, 226, 230, 233, 243, 250, 255] …</p>
<p>Nomal mode crit position: [1, 7, 25, 30, 31, 33, 35, 37, 42, 55, 64, 68, 70, 72, 75, 90, 91, 103, 106, 112, 116, 118, 120, 127, 129, 139, 140, 141, 143, 154, 158, 160, 161, 164, 170, 177, 196, 208, 209, 211, 220, 223, 238, 239, 264, 269, 270, 273, 274, 279] …</p>
<hr>
<p>看起来的确伪随机算法的离散程度要比PRD算法来的要大。我们把每次暴击间隔记录下来，然后以间隔为横轴，当前间隔发生的次数为纵轴绘制出一张柱状图出来，这样就能清晰地看出差距。</p>
<hr>
<p>输出:</p>
<p>PRD mode ins: {3: 294, 6: 254, 8: 134, 1: 115, 9: 87, 4: 301, 7: 226, 5: 287, 10: 50, 2: 227, 11: 26, 15: 1, 12: 5, 13: 4, 14: 2}</p>
<p>Nomal mode ins: {6: 140, 18: 8, 5: 147, 1: 374, 2: 315, 13: 25, 9: 60, 4: 188, 3: 274, 15: 19, 12: 41, 7: 97, 10: 52, 11: 54, 19: 8, 25: 5, 14: 23, 17: 11, 8: 70, 32: 1, 30: 1, 16: 19, 22: 4, 27: 2, 29: 3, 26: 2, 24: 1, 21: 3, 20: 4, 34: 2, 37: 1}</p>
<hr>
<p><img src="https://github.com/Westrel/Westrel.github.io/tree/master/images/randomgod/bar.png" alt="柱状图" title="PRD与伪随机的对比"></p>
<p>可以看出，伪随机算法的连续暴击的几率非常高，但是也有个别连续二三十次普攻不出暴击的。而对于PRD算法我们可以看到，大多数暴击间隔都在3到7之间，符合我们的期望（1/0.2-1=）4次普攻出一个暴击，并且极少存在间隔12以上的。</p>
<p>也许对于观众而言，一位选手连续出了三四个暴击逆风翻盘是比赛的吸睛之处，但是对于早已属于体育项目的电子竞技而言，选手的实力才是真正应当被记住的。过欧或过非都有可能会毁掉一支电竞队伍在过去一年来的不懈努力，也是因为这样，才有了PRD算法的诞生。我们应当感谢不断进步的一切，才有了更加公平的世界。</p>
<p>END（下一篇遥遥无期)</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTQ4MDAyMg==&mid=2247488424&idx=4&sn=94b9034efe3ba22579616a51918235f7&chksm=e9f30111de84880719b3835b255d4fe2a55c3634d5db5b7b3f722cb4d9fe771b467d449e6f95&mpshare=1&scene=23&srcid=&sharer_sharetime=1582345735177&sharer_shareid=fea2539564a751c8051ecf9b7d4f80e9#rd" target="_blank" rel="noopener">女朋友生气是随机事件？？？</a></p>
<p><a href="http://www.cppblog.com/NWAO/archive/2015/12/11/212458.html" target="_blank" rel="noopener">PRD算法中的C计算方法</a></p>
<p><a href="https://tieba.baidu.com/p/6142625005?red_tag=0255336677" target="_blank" rel="noopener">科普一下伪随机和PRD算法的区别</a></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/Westrel/Westrel.github.io/tree/master/download/PRD.py" target="_blank" rel="noopener">源码点这里(^.^)</a></p>

      </div>

      <div class="article-footer">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PRD/" rel="tag">#PRD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="tag">#概率论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B6%A3%E8%A7%A3%E7%AE%97%E6%B3%95/" rel="tag">#趣解算法</a></li></ul>
      </div>

      <div class="article-navs">
        
<nav class="card-container card-article-nav">
  <div class="card-wrap">
    
      <div id="article-nav-newer" class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/2020/win10%E5%8F%98wifi/"></a>
          <strong class="article-nav-caption">Newer</strong>
          <p class="article-nav-title">
            
              win10变wifi
            
          </p>
        </article>
      </div>
    
    
      <div id="article-nav-older" class="card-item img">
        <article>
          
            <div class="card-cover" style="background-image: url(../images/zaishijieshenchudeshijie/1.jpg)"></div>
          
          <a class="card-link article-nav-link" href="/2020/%E5%9C%A8%E4%B8%96%E7%95%8C%E6%B7%B1%E5%A4%84%E7%9A%84%E4%B8%96%E7%95%8C/"></a>
          <strong class="article-nav-caption">Older</strong>
          <p class="article-nav-title">
            
              在世界深处的世界
            
          </p>
        </article>
      </div>
    
  </div>
</nav>

      </div>
      
      

  
  <div class="valine-container">
    <div id="valine_thread" class="valine-thread"></div>
  </div>

  
  


    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    <p>&copy; 2020 <a href="/" target="_blank">Westrel Xylographer</a></p>

    
      <p id="hitokoto"></p>
      <script src="https://v1.hitokoto.cn/?c=a&amp;encode=js&select=%23hitokoto" defer></script>
    

    

    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank">flex-block</a></p>
  </div>
</footer>
  </div>

  
  


  <!-- aplayer 音频 start -->
  
<link rel="stylesheet" href="/lib/APlayer.min.css">

  
<script src="/lib/APlayer.min.js"></script>

  <script type="text/javascript">
    const aplayer = document.querySelectorAll(".aplayer");
    aplayer && initaplayer(aplayer);
    function initaplayer(els) {
      let elsArr = Array.from(els);
      elsArr.forEach(el => {
        new APlayer({
          container: el,
          audio: { ...el.dataset },
          theme: "#b7daff",
          lrcType: 3,
          autoplay: false,
          loop: false,
          mutex: true,
        });
      });
    }
  </script>
  <!-- aplayer 音频 end -->
  

<!-- dplayer 视频 start -->

<link rel="stylesheet" href="/lib/DPlayer.min.css">


<script src="/lib/DPlayer.min.js"></script>

<script type="text/javascript">
  const dplayer = document.querySelectorAll(".dplayer");
  dplayer && initDPlayer(dplayer);
  function initDPlayer(els) {
    let elsArr = Array.from(els);
    elsArr.forEach(el => {
      let url = el.dataset.url;
      let cover = el.dataset.cover;
      new DPlayer({
        container: el,
        video: { url: url, pic: cover },
        theme: "#b7daff",
        autoplay: false,
        loop: false,
        mutex: true,
      });
    });
  }
</script>
<!-- dplayer 视频 end -->


<!-- waterfall 瀑布流 start -->

<script src="/lib/waterfall.min.js"></script>

<script type="text/javascript">

const waterfalls = document.querySelectorAll(".waterfall-container");

if (waterfalls && waterfalls.length > 0) {
  waterfalls.forEach((waterfall, index) => {
    let cls = "waterfall-container-" + index;
    waterfall.classList.add(cls);
    initWaterfall(cls, waterfall);
  });
}

function initWaterfall(selector, el) {
  const options = {};
  if (Object.keys(el.dataset).length > 0) {
    for (let k in el.dataset) {
      options[k] = el.dataset[k];
    }
  }
  waterfall(`.${selector}`, options);
}
</script>
<!-- waterfall 瀑布流 end -->


  <!-- zoom start -->
  
<script src="/lib/zoom.min.js"></script>

  <script type="text/javascript">
    document.querySelector(".article-content") && zoom(".article-content");
  </script>
  <!-- zoom end -->
  



  


  


  




<script src="/js/script.js"></script>

  
  <!-- 尾部用户自定义相关内容 -->

</body>
</html>