<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
    <meta name="description" content="Designed by Wx">
  

  
    <meta name="keywords" content="由列表掉落关键词">
  

  
    <meta name="author" content="Westrel Xylographer">
  

  

  

  <title>二叉树那些事 | 你是光</title>

  

  
    <link rel="icon" href="/favicon.ico">
  

  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.6/styles/monokai.min.css" rel="stylesheet">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div class="root-container">
    <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          你是光
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/categories">目录</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/tags">标签</a></li>
        
          <li class="navbar-list-item"><a href="/messages">留盐</a></li>
        
      </ul>
    </div>
  </div>
</nav>

    
<!-- header container -->
<header class="header-container post">

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-image" style="background-image: url(./images/bintree1/1.jpg)"></div>
      <div class="post-text">
        <div class="type-wrap">
          <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        </div>
        <h1 class="title-wrap">二叉树那些事</h1>
        <h2 class="title-sub-wrap">
          <strong>Westrel Xylographer</strong>
          <span>发布于</span>
          
  <a href="javascript:;" class="article-date">
    <time datetime="2020-03-08T06:56:48.000Z" itemprop="datePublished">2020-03-08</time>
  </a>

        </h2>
      </div>
    </div>
  

  
  

  </header>

    <!-- 文章 -->

<!-- 文章内容 -->

<div class="body-container">
  <article class="content-container article-container">
    <div class="article-content">
      
      

      <div class="article-entry">
        <p>想必大家都还记得高中生物课的那些个遗传系谱图，那些AaBb把我们耍的晕头转向的。那是我们接触过的最早的数学上的树结构，我们正是通过那种不断推断出某人的父亲母亲患病几率，再推断出某人的儿子女儿患病几率，最终得出那个和最初的携带者八竿子打不着的亲戚的能不能生儿子的。树结构和我们的关系紧密相连，比如，习大大想要找到你，得先找省委，再找市委，随后找到你工作的部门，再找到你的上司，最终才能亲切地走到你面前，笑眯眯地对你说：“2020终于要消灭你了，真是中国的一大幸事啊！”故事纯属虚构，但这树结构可不假。树形结构体现了一个组织的层序关系，能够更快地索引到目标。试想，如果习大大从第一个身份证号看起，想要找到你那得花多长时间？</p>
<p>在万千种树当中，有一种最基本的树，不是高数，也不是为人民奉献的行道树，而是<b>二叉树</b>.。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><a href="[https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=aladdin](https://baike.baidu.com/item/二叉树/1602879?fr=aladdin)">二叉树</a></h1><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。(来源于百度百科)</p>
<p>书写本文的目的是搞清楚建树的过程以及6种遍历方式的C语言实现。话不多说，直接进入正题。</p>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>在c语言里，我们使用结构体来构造二叉树节点。节点实现很简单，一个数据域data定义为ElementType类型，具体需要什么类型直接修改ElementType就ok；两个指向该结构体的指针分别为左孩子和右孩子。下面是代码部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span>&#123;</span>		<span class="hljs-comment">// 二叉树</span><br>	ElementType data;	<span class="hljs-comment">// 数据域 </span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span> *<span class="hljs-title">left</span>;</span>		<span class="hljs-comment">// 左子树 </span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span> *<span class="hljs-title">right</span>;</span>	<span class="hljs-comment">// 右子树 </span><br>&#125;BinTree;<br></code></pre></td></tr></table></figure>

<p>建树时我们使用一个createNewNode创建二叉树的节点，该函数需要一个data以初始化返回节点的data域。节点的左右孩子都被指向NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BinTree *<span class="hljs-title">createNewNode</span><span class="hljs-params">(ElementType data)</span></span>&#123;			<span class="hljs-comment">// 创建二叉树节点 </span><br>	BinTree *node;<br>	node = (BinTree*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BinTree));<br>	node-&gt;data = data;<br>	node-&gt;left = <span class="hljs-literal">NULL</span>;<br>	node-&gt;right = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再使用一个connectChild函数来为一个父节点的左右孩子赋值。其中，如果传入NULL则不改变当前父节点的当前子节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connectChild</span><span class="hljs-params">(BinTree* parent, BinTree* lchild, BinTree* rchild)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(lchild)<br>		parent-&gt;left = lchild;<br>	<span class="hljs-keyword">if</span>(rchild)<br>		parent-&gt;right = rchild;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样一来，我们只要多次使用BinTree声明一个节点的指针并用createNewNode和connectChild初始化，便很快能构造出一个属于你自己的二叉树。构造完成之后，之后需要进行查找等操作就是遍历的事了。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二叉树的遍历主要有三种，先序、中序和后序遍历。其中这个先、中、后指的是父节点相对于子节点的顺序，而子节点都是先左后右的。具体请看图：</p>
<p><img src="../images/bintree1/2.png" alt="遍历方式" title="遍历方式"></p>
<p>这样一看我们的思路就很清晰了，如果是先序遍历，拿到一个父节点的指针p，先输出p所指向的数据域，随后去遍历左子树，遍历完成之后再去遍历右子树。中序和后序也都是这个道理，只不过是拿到p之后的操作顺序不同。那么，有了这个思路，我们首先想到的就是递归，因为遍历左右子树的时候仍然是进行相同的操作。递归就不需要解释了，直接上代码</p>
<h3 id="三种递归遍历代码"><a href="#三种递归遍历代码" class="headerlink" title="三种递归遍历代码"></a>三种递归遍历代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recursivePreorderTraversal</span><span class="hljs-params">(BinTree* root)</span></span>&#123;		<span class="hljs-comment">// 递归先序遍历二叉树 </span><br>	BinTree *tag;<br>	tag = root;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tag-&gt;data);<br>	<span class="hljs-keyword">if</span>(tag-&gt;left != <span class="hljs-literal">NULL</span>)<br>		recursivePreorderTraversal(tag-&gt;left);<br>	<span class="hljs-keyword">if</span>(tag-&gt;right != <span class="hljs-literal">NULL</span>)<br>		recursivePreorderTraversal(tag-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recursiveMiddleorderTraversal</span><span class="hljs-params">(BinTree* root)</span></span>&#123;	<span class="hljs-comment">// 递归中序遍历二叉树 </span><br>	BinTree *tag;<br>	tag = root;<br>	<span class="hljs-keyword">if</span>(tag-&gt;left != <span class="hljs-literal">NULL</span>)<br>		recursiveMiddleorderTraversal(tag-&gt;left);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tag-&gt;data);<br>	<span class="hljs-keyword">if</span>(tag-&gt;right != <span class="hljs-literal">NULL</span>)<br>		recursiveMiddleorderTraversal(tag-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recursivePostorderTraversal</span><span class="hljs-params">(BinTree* root)</span></span>&#123;	<span class="hljs-comment">// 递归后序遍历二叉树 </span><br>	BinTree *tag;<br>	tag = root;<br>	<span class="hljs-keyword">if</span>(tag-&gt;left != <span class="hljs-literal">NULL</span>)<br>		recursivePostorderTraversal(tag-&gt;left);<br>	<span class="hljs-keyword">if</span>(tag-&gt;right != <span class="hljs-literal">NULL</span>)<br>		recursivePostorderTraversal(tag-&gt;right);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tag-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出，上述三部分代码几乎都是一样的，不一样的仅仅是printf的位置。</p>
<p>但是，递归可能会碰到一个问题：如果一棵二叉树的更扎的很深(大白话)，碰巧我们又有递归深度的限制，那么这种耗内存的办法就很危险了。于是，我们开发出了用栈来实现的非递归方法。</p>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>非递归主要是需要用到栈。栈可以理解为一种内容物直径与其自身内径一样大的容器(比如那种卷装的小样(打个广告，我高中的时候老喜欢吃这种小样了))可能大多数人吃的时候和我一样，直接把包装撕开吃，我想吃哪个就吃哪个，这种吃法很像数组，我想吃第N个直接索引到第N个取出来。但是栈不一样，栈是只把包装的一端打开，想吃的时候从这一端取出来，取多了只能从这一端再放回去。和栈对应的是队列，队列和栈的区别在于，队列是把小样两端都打开，并且规定只能从某一段取出来，只能从另一端放进去，就像排队的人，通常情况下新来的人只能从队尾入队，办理完事务的人只能从队首出队，不允许插队的情况。</p>
<p><img src="../images/bintree1/3.jpg" alt="小样" title="小样"></p>
<h4 id="构造栈"><a href="#构造栈" class="headerlink" title="构造栈"></a>构造栈</h4><p>在实现非递归算法之前，我们先把需要的工具构造出来。鉴于栈和队列有一定的相似性，我们就把二者统一化处理了。</p>
<p>前面说，栈和队列就相当于一个容器，于是我们构造出一个容器以及内容物，容器有头结点和尾节点的指针，最大容量与当前容量。内容物则含有前驱与后继的指针以及本身二叉树节点的指针。SaQ取名自stack and queue，栈和队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span>&#123;</span>		<span class="hljs-comment">// 容器内节点</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span> *<span class="hljs-title">fore</span>;</span>		<span class="hljs-comment">// 前驱 </span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span> *<span class="hljs-title">next</span>;</span>		<span class="hljs-comment">// 后继 </span><br>	BinTree *self;		<span class="hljs-comment">// 本身节点 </span><br>&#125;SaQNode;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Z</span>&#123;</span>		<span class="hljs-comment">// 双向链表, 充当容纳树的队列和栈的容器 </span><br>	SaQNode *head;		<span class="hljs-comment">// 容器头 </span><br>	SaQNode *tail;		<span class="hljs-comment">// 容器尾 </span><br>	<span class="hljs-keyword">int</span> length;			<span class="hljs-comment">// 容器中储量 </span><br>	<span class="hljs-keyword">int</span> maxsize;		<span class="hljs-comment">// 容量 </span><br>&#125;SAQ;<br></code></pre></td></tr></table></figure>

<p>内容物在创建时我们只需要传入一个二叉树节点的指针，便可以返回一个内容物的指针。而容器也同样，传入最大容量，返回一个空的容器，如果最大容量&lt;=0则将其设为预设好的最大值，此处为2^31。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">SaQNode *<span class="hljs-title">createSaQNode</span><span class="hljs-params">(BinTree *btNode)</span></span>&#123;			<span class="hljs-comment">// 创建内容物 </span><br>	SaQNode *saqnode;<br>	saqnode = (SaQNode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SaQNode));<br>	saqnode-&gt;fore = <span class="hljs-literal">NULL</span>;<br>	saqnode-&gt;next = <span class="hljs-literal">NULL</span>;<br>	saqnode-&gt;self = btNode;<br>	<span class="hljs-keyword">return</span> saqnode;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">SAQ *<span class="hljs-title">createSAQ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxsize)</span></span>&#123;						<span class="hljs-comment">// 创建容器 </span><br>	SAQ *saq;<br>	SaQNode *head;<br>	saq = (SAQ*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SAQ));<br>	head = (SaQNode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SaQNode));<br>	head-&gt;fore = <span class="hljs-literal">NULL</span>;<br>	head-&gt;next = <span class="hljs-literal">NULL</span>;<br>	head-&gt;self = <span class="hljs-literal">NULL</span>;<br>	saq-&gt;head = <span class="hljs-literal">NULL</span>;<br>	saq-&gt;tail = saq-&gt;head;<br>	saq-&gt;length = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(maxsize &lt; <span class="hljs-number">0</span>)<br>		saq-&gt;maxsize = MAX_SAQ_SIZE;<br>	<span class="hljs-keyword">else</span><br>		saq-&gt;maxsize = maxsize;<br>	<span class="hljs-keyword">return</span> saq;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于栈和队列，都共同含有队尾的push操作。而区别在于出栈和出队，分别从尾和头pop出去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pushSAQ</span><span class="hljs-params">(SAQ *saq, BinTree *btnode)</span></span>&#123;			<span class="hljs-comment">// 容器尾push操作 </span><br>	SaQNode *node;<br>	node = createSaQNode(btnode);<br>	<span class="hljs-keyword">if</span>(saq-&gt;length == saq-&gt;maxsize)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"SAQ已满\n"</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(saq-&gt;length == <span class="hljs-number">0</span>)&#123;<br>		saq-&gt;head = node;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		saq-&gt;tail-&gt;next = node;<br>		node-&gt;fore = saq-&gt;tail;<br>	&#125;<br>	saq-&gt;tail = node;<br>	(saq-&gt;length) ++;<br><span class="hljs-comment">//	printf("push: 当前容量: %d\n", saq-&gt;length);</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BinTree *<span class="hljs-title">stackPop</span><span class="hljs-params">(SAQ *saq)</span></span>&#123;						<span class="hljs-comment">// 栈pop操作 </span><br>	SaQNode *p;<br>	<span class="hljs-keyword">if</span>(saq-&gt;length == <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"SAQ空"</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(saq-&gt;length == <span class="hljs-number">1</span>)&#123;<br>		p = saq-&gt;tail;<br>		saq-&gt;head = <span class="hljs-literal">NULL</span>;<br>		saq-&gt;tail = <span class="hljs-literal">NULL</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		p = saq-&gt;tail;<br>		saq-&gt;tail = saq-&gt;tail-&gt;fore;<br>		p-&gt;fore = <span class="hljs-literal">NULL</span>;<br>		saq-&gt;tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	(saq-&gt;length) --;<br><span class="hljs-comment">//	printf("stackpop: 当前容量%d\n", saq-&gt;length);</span><br>	<span class="hljs-keyword">return</span> p-&gt;self;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BinTree *<span class="hljs-title">queuePop</span><span class="hljs-params">(SAQ *saq)</span></span>&#123;						<span class="hljs-comment">// 队列pop操作 </span><br>	SaQNode *p;<br>	<span class="hljs-keyword">if</span>(saq-&gt;length == <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"SAQ空"</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(saq-&gt;length == <span class="hljs-number">0</span>)&#123;<br>		p = saq-&gt;head;<br>		saq-&gt;head = <span class="hljs-literal">NULL</span>;<br>		saq-&gt;tail = <span class="hljs-literal">NULL</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		p = saq-&gt;head;<br>		saq-&gt;head = saq-&gt;head-&gt;next;<br>		p-&gt;next = <span class="hljs-literal">NULL</span>;<br>		saq-&gt;head-&gt;fore = <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	(saq-&gt;length) --;<br><span class="hljs-comment">//	printf("stackpop: 当前容量%d\n", saq-&gt;length);</span><br>	<span class="hljs-keyword">return</span> p-&gt;self;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在已经写好的函数当中，为了简化操作，我们特地使push时只需要push二叉树节点即可，转化为内容物的操作已经封装在了函数里，同样，两个pop也只会pop出二叉树节点而不是内容物。那么，现在我们如果需要使用栈，只需要先createSAQ创建容器，再进行相应的push和pop操作即可。</p>
<p>我们也有显示容器内容物的相关代码，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">showSaQData</span><span class="hljs-params">(SAQ *saq)</span></span>&#123;							<span class="hljs-comment">// 显示容器内容物 </span><br>	SaQNode *p;<br>	p = saq-&gt;head;<br>	<span class="hljs-keyword">if</span>(saq-&gt;length == <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"SAQ为空\n"</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"head-&gt;"</span>);<br>	<span class="hljs-keyword">while</span>(p)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>, p-&gt;self-&gt;data);<br>		<span class="hljs-keyword">if</span>(p-&gt;next)<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"&lt;-&gt;"</span>);<br>		p = p-&gt;next;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"&lt;-tail\n"</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>下面就是我们的最后部分，非递归遍历二叉树的算法实现。</p>
<h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><p>先序比较简单，我们把根节点先压入栈，每次操作时，先pop栈顶元素，再把右孩子和左孩子依次压入栈，直到栈空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noRecursivePreorderTraversal</span><span class="hljs-params">(BinTree* root)</span></span>&#123;	<span class="hljs-comment">// 非递归先序遍历二叉树 </span><br>	SAQ *<span class="hljs-built_in">stack</span>;<br>	BinTree *p;<br>	<span class="hljs-built_in">stack</span> = createSAQ(<span class="hljs-number">-1</span>);<br>	p = root;<br>	<span class="hljs-keyword">if</span>(!root)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"树为空\n"</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	pushSAQ(<span class="hljs-built_in">stack</span>, p);<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">stack</span>-&gt;length)&#123;<br>		p = stackPop(<span class="hljs-built_in">stack</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>		<span class="hljs-keyword">if</span>(p-&gt;right)<br>			pushSAQ(<span class="hljs-built_in">stack</span>, p-&gt;right);<br>		<span class="hljs-keyword">if</span>(p-&gt;left)<br>			pushSAQ(<span class="hljs-built_in">stack</span>, p-&gt;left);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>中序遍历时，稍微麻烦一点。每一个节点入栈后开始访问左节点，直到左节点全部访问完，开始访问本身和右节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noRecursiveMiddleorderTraversal</span><span class="hljs-params">(BinTree* root)</span></span>&#123;<span class="hljs-comment">// 非递归中序遍历二叉树 </span><br>	SAQ *<span class="hljs-built_in">stack</span>;<br>	BinTree *p;<br>	<span class="hljs-built_in">stack</span> = createSAQ(<span class="hljs-number">-1</span>);<br>	p = root;<br>	<span class="hljs-keyword">if</span>(!root)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"树为空\n"</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">stack</span>-&gt;length != <span class="hljs-number">0</span> || p)&#123;<br>		<span class="hljs-keyword">while</span>(p)&#123;<br>			pushSAQ(<span class="hljs-built_in">stack</span>, p);<br>			p = p-&gt;left;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">stack</span>-&gt;length != <span class="hljs-number">0</span>)&#123;<br>			p = <span class="hljs-built_in">stack</span>-&gt;tail-&gt;self;<br>			stackPop(<span class="hljs-built_in">stack</span>);<br>  			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>  			p = p-&gt;right;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>后序遍历就会面临一个问题：我拿到一个节点，先去访问左孩子访问完了之后再回到我的当前节点，再去访问右孩子，都访问完之后才能访问我自身。那么当我回到我自身的时候，我怎么知道是访问我自己还是访问右孩子呢？这里有两种解决办法，一种是给每个节点设一个flag，默认为0，当我左孩子访问完之后回来看，我的flag为0，表示右孩子还没有访问，所以应该去访问右孩子并将flag设为1，这样我再回来的时候看见flag为1就知道应该访问自身了。这种方法称为回溯。还有一种办法是巧妙利用栈可以访问栈顶元素的特性，每次压栈时将同一节点两次压入栈中，在循环中，如果pop出的p和栈顶元素相同表示第一种方法中的”0”，如果不同则表示”1”。这种方法很巧妙，我们就使用这种方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noRecursivePostorderTraversal</span><span class="hljs-params">(BinTree* root)</span></span>&#123;	<span class="hljs-comment">// 非递归后序遍历二叉树 </span><br>	SAQ *<span class="hljs-built_in">stack</span>;<br>	BinTree *p;<br>	<span class="hljs-built_in">stack</span> = createSAQ(<span class="hljs-number">-1</span>);<br>	p = root;<br>	<span class="hljs-keyword">if</span>(!root)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"树为空\n"</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	pushSAQ(<span class="hljs-built_in">stack</span>, root);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, root);<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">stack</span>-&gt;length)&#123;<br>		p = stackPop(<span class="hljs-built_in">stack</span>);<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">stack</span>-&gt;length &amp;&amp; p == <span class="hljs-built_in">stack</span>-&gt;tail-&gt;self)&#123;<br>			<span class="hljs-keyword">if</span>(p-&gt;right)&#123;<br>				pushSAQ(<span class="hljs-built_in">stack</span>, p-&gt;right);<br>				pushSAQ(<span class="hljs-built_in">stack</span>, p-&gt;right);<br>			&#125;<br>			<span class="hljs-keyword">if</span>(p-&gt;left)&#123;<br>				pushSAQ(<span class="hljs-built_in">stack</span>, p-&gt;left);<br>				pushSAQ(<span class="hljs-built_in">stack</span>, p-&gt;left);<br>			&#125;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>除了上述三种之外还有一种就是层序遍历，其实就是从上到下从左到右把全部节点数出来，并没有什么难度，唯一的区别就是使用的是队列，每次pop一个节点并把左右孩子压入队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">levelTraversal</span><span class="hljs-params">(BinTree* root)</span></span>&#123;					<span class="hljs-comment">// 层序遍历二叉树 </span><br>	BinTree *p;<br>	SAQ *<span class="hljs-built_in">queue</span>; <br>	<span class="hljs-keyword">if</span>(!root)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"树为空\n"</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	p = root;<br>	<span class="hljs-built_in">queue</span> = createSAQ(<span class="hljs-number">-1</span>);<br>	pushSAQ(<span class="hljs-built_in">queue</span>, p);<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">queue</span>-&gt;length)&#123;<br>		p = queuePop(<span class="hljs-built_in">queue</span>);<br>		<span class="hljs-keyword">if</span>(p-&gt;left)<br>			pushSAQ(<span class="hljs-built_in">queue</span>, p-&gt;left);<br>		<span class="hljs-keyword">if</span>(p-&gt;right)<br>			pushSAQ(<span class="hljs-built_in">queue</span>, p-&gt;right);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>在我的例子中，我建立了一个如图所示的二叉树，分别用七种方法遍历得到结果</p>
<p><img src="../images/bintree1/4.png" alt="二叉树" title="二叉树"></p>
<p>遍历代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> i;<br>	SAQ *<span class="hljs-built_in">stack</span>, *que;<br>	BinTree *root, *bt1, *bt2, *bt3, *bt4, *bt5;<br>	BinTree *bintree[<span class="hljs-number">5</span>];<br>	root = createNewNode(<span class="hljs-number">0</span>);<br>	bt1 = createNewNode(<span class="hljs-number">1</span>);<br>	bt2 = createNewNode(<span class="hljs-number">2</span>);<br>	bt3 = createNewNode(<span class="hljs-number">3</span>);<br>	bt4 = createNewNode(<span class="hljs-number">4</span>);<br>	bt5 = createNewNode(<span class="hljs-number">5</span>);<br>	connectChild(root, bt1, bt2);<br>	connectChild(bt1, bt3, bt4);<br>	connectChild(bt2, bt5, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"递归先序遍历: "</span>);<br>	recursivePreorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"非递归先序遍历: "</span>);<br>	noRecursivePreorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"递归中序遍历: "</span>);<br>	recursiveMiddleorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"非递归中序遍历: "</span>);<br>	noRecursiveMiddleorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"递归后序遍历: "</span>);<br>	recursivePostorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"非递归后序遍历: "</span>);<br>	noRecursivePostorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"层序遍历: "</span>);<br>	levelTraversal(root);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="../images/bintree1/5.png" alt="遍历结果" title="遍历结果"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="全部测试代码"><a href="#全部测试代码" class="headerlink" title="全部测试代码"></a>全部测试代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> i;<br>	SAQ *<span class="hljs-built_in">stack</span>, *que;<br>	BinTree *root, *bt1, *bt2, *bt3, *bt4, *bt5;<br>	BinTree *bintree[<span class="hljs-number">5</span>];<br>	root = createNewNode(<span class="hljs-number">0</span>);<br>	bt1 = createNewNode(<span class="hljs-number">1</span>);<br>	bt2 = createNewNode(<span class="hljs-number">2</span>);<br>	bt3 = createNewNode(<span class="hljs-number">3</span>);<br>	bt4 = createNewNode(<span class="hljs-number">4</span>);<br>	bt5 = createNewNode(<span class="hljs-number">5</span>);<br>	connectChild(root, bt1, bt2);<br>	connectChild(bt1, bt3, bt4);<br>	connectChild(bt2, bt5, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"递归先序遍历: "</span>);<br>	recursivePreorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"非递归先序遍历: "</span>);<br>	noRecursivePreorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"递归中序遍历: "</span>);<br>	recursiveMiddleorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"非递归中序遍历: "</span>);<br>	noRecursiveMiddleorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"递归后序遍历: "</span>);<br>	recursivePostorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"非递归后序遍历: "</span>);<br>	noRecursivePostorderTraversal(root);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"层序遍历: "</span>);<br>	levelTraversal(root);<br>	<br>	<span class="hljs-built_in">stack</span> = createSAQ(<span class="hljs-number">10</span>);<br>	showSaQData(<span class="hljs-built_in">stack</span>);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, root);<br>	stackPop(<span class="hljs-built_in">stack</span>);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, bt1);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, bt1);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, bt2);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, bt3);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, bt4);<br>	pushSAQ(<span class="hljs-built_in">stack</span>, bt5);<br>	showSaQData(<span class="hljs-built_in">stack</span>);<br>	stackPop(<span class="hljs-built_in">stack</span>);<br>	queuePop(<span class="hljs-built_in">stack</span>);<br>	showSaQData(<span class="hljs-built_in">stack</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面一部分是容器的操作，结果如下：</p>
<p><img src="../images/bintree1/6.png" alt="容器操作结果" title="容器操作结果"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_38362252/article/details/82936148" target="_blank" rel="noopener">二叉树的非递归遍历</a></p>
<p><a href="https://www.icourse163.org/course/ZJU-93001" target="_blank" rel="noopener">浙江大学数据结构精品MOOC</a></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>本文的全部C源码<a href="../download/tree.c">点这里</a></p>
<p>END(下一篇遥遥无期)</p>

      </div>

      <div class="article-footer">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">#C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">#二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B6%A3%E8%A7%A3%E7%AE%97%E6%B3%95/" rel="tag">#趣解算法</a></li></ul>
      </div>

      <div class="article-navs">
        
<nav class="card-container card-article-nav">
  <div class="card-wrap">
    
    
      <div id="article-nav-older" class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/win10%E5%8F%98wifi/"></a>
          <strong class="article-nav-caption">Older</strong>
          <p class="article-nav-title">
            
              win10变wifi
            
          </p>
        </article>
      </div>
    
  </div>
</nav>

      </div>
      
      

  
  <div class="valine-container">
    <div id="valine_thread" class="valine-thread"></div>
  </div>

  
  


    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    <p>&copy; 2020 <a href="/" target="_blank">Westrel Xylographer</a></p>

    
      <p id="hitokoto"></p>
      <script src="https://v1.hitokoto.cn/?c=a&amp;encode=js&select=%23hitokoto" defer></script>
    

    

    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank">flex-block</a></p>
  </div>
</footer>
  </div>

  
  


  <!-- aplayer 音频 start -->
  
<link rel="stylesheet" href="/lib/APlayer.min.css">

  
<script src="/lib/APlayer.min.js"></script>

  <script type="text/javascript">
    const aplayer = document.querySelectorAll(".aplayer");
    aplayer && initaplayer(aplayer);
    function initaplayer(els) {
      let elsArr = Array.from(els);
      elsArr.forEach(el => {
        new APlayer({
          container: el,
          audio: { ...el.dataset },
          theme: "#b7daff",
          lrcType: 3,
          autoplay: false,
          loop: false,
          mutex: true,
        });
      });
    }
  </script>
  <!-- aplayer 音频 end -->
  

<!-- dplayer 视频 start -->

<link rel="stylesheet" href="/lib/DPlayer.min.css">


<script src="/lib/DPlayer.min.js"></script>

<script type="text/javascript">
  const dplayer = document.querySelectorAll(".dplayer");
  dplayer && initDPlayer(dplayer);
  function initDPlayer(els) {
    let elsArr = Array.from(els);
    elsArr.forEach(el => {
      let url = el.dataset.url;
      let cover = el.dataset.cover;
      new DPlayer({
        container: el,
        video: { url: url, pic: cover },
        theme: "#b7daff",
        autoplay: false,
        loop: false,
        mutex: true,
      });
    });
  }
</script>
<!-- dplayer 视频 end -->


<!-- waterfall 瀑布流 start -->

<script src="/lib/waterfall.min.js"></script>

<script type="text/javascript">

const waterfalls = document.querySelectorAll(".waterfall-container");

if (waterfalls && waterfalls.length > 0) {
  waterfalls.forEach((waterfall, index) => {
    let cls = "waterfall-container-" + index;
    waterfall.classList.add(cls);
    initWaterfall(cls, waterfall);
  });
}

function initWaterfall(selector, el) {
  const options = {};
  if (Object.keys(el.dataset).length > 0) {
    for (let k in el.dataset) {
      options[k] = el.dataset[k];
    }
  }
  waterfall(`.${selector}`, options);
}
</script>
<!-- waterfall 瀑布流 end -->


  <!-- zoom start -->
  
<script src="/lib/zoom.min.js"></script>

  <script type="text/javascript">
    document.querySelector(".article-content") && zoom(".article-content");
  </script>
  <!-- zoom end -->
  



  


  


  




<script src="/js/script.js"></script>

  
  <!-- 尾部用户自定义相关内容 -->

</body>
</html>